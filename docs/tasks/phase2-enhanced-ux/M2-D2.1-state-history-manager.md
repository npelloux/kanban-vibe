# [M2-D2.1] Implement state history manager for undo/redo

## Deliverable: State snapshots captured on significant actions enabling undo/redo functionality

### Context
**PRD:** `docs/project/PRD/active/PRD-phase2-enhanced-ux.md` — M2: Undo/Redo System, D2.1

Currently, mistakes during simulation require reloading saved state or starting over. This deliverable creates a history manager that captures state snapshots on significant actions, forming the foundation for undo/redo functionality.

### Traceability
- **PRD Section:** M2-D2.1 "State history manager"
- **Functional Requirement:** Capture state snapshots on card creation, movement, worker assignment, day advancement, WIP limit changes
- **Success Criteria:** SC-2 "State changes create history entries"

### Acceptance Criteria
- [ ] History manager captures state on card creation (handleAddCard)
- [ ] History manager captures state on card movement (handleCardClick)
- [ ] History manager captures state on worker assignment (handleWorkerDrop)
- [ ] History manager captures state on day advancement (handleNextDay)
- [ ] History manager captures state on WIP limit changes (handleWipLimitUpdate)
- [ ] History stack limited to 50 entries (oldest removed when exceeded)
- [ ] Each entry includes: timestamp, action name, full state snapshot
- [ ] History manager exposes canUndo() and canRedo() methods

### Edge Case Scenarios
- Perform 60 actions → Only most recent 50 entries retained, oldest 10 removed
- Rapid actions within same millisecond → Each action gets unique entry
- Policy execution (50 days) → Each day creates one history entry (may exceed limit)
- Empty state at startup → History starts with initial state entry
- Import context → History resets with imported state as first entry

### Implementation Guidelines
- Create new file `src/hooks/useHistoryManager.ts` as a custom React hook
- Interface matches PRD specification in Section 7:
```typescript
interface HistoryEntry {
  timestamp: number;
  action: string;
  state: KanbanState;
}

interface HistoryManager {
  entries: HistoryEntry[];
  currentIndex: number;
  maxDepth: number;
  push(action: string, state: KanbanState): void;
  undo(): KanbanState | null;
  redo(): KanbanState | null;
  canUndo(): boolean;
  canRedo(): boolean;
}
```
- Use `useRef` for entries array to avoid re-renders on every push
- Expose state via `useState` for currentIndex to trigger UI updates
- When pushing after undo, truncate forward history (standard undo behavior)
- Deep clone state on push to prevent mutation issues

### Embedded Reasoning
**Why:** Users make mistakes during simulation and need to reverse actions without losing all progress—this is core to "safe experimentation."
**What:** A history manager that snapshots state on significant actions with configurable depth limit.
**How:** Custom React hook using useRef for history array and useState for index, with push/undo/redo operations.

### Testing Strategy
- **Unit:** Test push adds entry with correct timestamp and action name
- **Unit:** Test maxDepth enforcement removes oldest entries
- **Unit:** Test undo returns previous state and decrements index
- **Unit:** Test redo returns next state and increments index
- **Unit:** Test canUndo/canRedo return correct booleans at boundaries
- **Unit:** Test push after undo truncates forward history
- **Edge Cases:** Test 50+ actions, test empty history, test at boundaries

### Dependencies
None - this is foundational for M2-D2.2 (Undo) and M2-D2.3 (Redo)

### Verification
1. Create hook in test file → `push()` adds entries
2. Call `push()` 55 times → `entries.length` equals 50
3. Call `undo()` → Returns previous state, `canRedo()` returns true
4. Call `push()` after undo → Forward history truncated
5. Run `npm test` → All history manager tests pass
